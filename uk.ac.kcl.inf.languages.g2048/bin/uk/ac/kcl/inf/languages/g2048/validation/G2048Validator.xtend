/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.inf.languages.g2048.validation

import org.eclipse.xtext.validation.Check
import uk.ac.kcl.inf.languages.g2048.g2048.SizeDefineStatement
import uk.ac.kcl.inf.languages.g2048.g2048.TitleDefineStatement
import uk.ac.kcl.inf.languages.g2048.g2048.LevelDefineStatement
import uk.ac.kcl.inf.languages.g2048.g2048.G2048Program
import uk.ac.kcl.inf.languages.g2048.g2048.G2048Package
import uk.ac.kcl.inf.languages.g2048.g2048.Statement
import uk.ac.kcl.inf.languages.g2048.g2048.Level
import java.util.Collections
import uk.ac.kcl.inf.languages.g2048.typing.validation.g2048TypeSystemValidator

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class G2048Validator extends g2048TypeSystemValidator {
	
	public static val INVALID_CHECK_SIZE  = 'uk.ac.kcl.inf.languages.g2048.INVALID_CHECK_SIZE'
	public static val INVALID_CHECK_TITLE  = 'uk.ac.kcl.inf.languages.g2048.INVALID_CHECK_TITLE'
	public static val INVALID_CHECK_ORDER  = 'uk.ac.kcl.inf.languages.g2048.INVALID_CHECK_ORDER'
	public static val INVALID_CHECK_LEVEL  = 'uk.ac.kcl.inf.languages.g2048.INVALID_CHECK_LEVEL'
	public static val INVALID_CHECK_DUP  = 'uk.ac.kcl.inf.languages.g2048.INVALID_CHECK_DUP'
	public static val INVALID_CHECK_LEVEL_VARIABLE = 'uk.ac.kcl.inf.languages.g2048.INVALID_CHECK_LEVEL_VARIABLE'
	
	@Check
	def checkMapsize(SizeDefineStatement decl) {
		if(decl.size < 2 ) {
	  		warning('Map size should be larger than 1 ', decl, G2048Package.Literals.SIZE_DEFINE_STATEMENT__SIZE, INVALID_CHECK_SIZE);
	  }
	}
	
	@Check
	def checktitle(TitleDefineStatement decl) { 
		if((decl.title).isEmpty()) {
	  		warning('Title should not be empty', decl, G2048Package.Literals.TITLE_DEFINE_STATEMENT__TITLE, INVALID_CHECK_TITLE);
	 }
	}
	
	@Check
	def checkLevelvalue(LevelDefineStatement decl) { 
		if((decl.element).isEmpty()) {
	  		warning('Level variable should not be empty', decl, G2048Package.Literals.LEVEL_DEFINE_STATEMENT__ELEMENT, INVALID_CHECK_LEVEL_VARIABLE);
	 }
	}
	
	@Check(NORMAL)
	def checkOrderLevelAndNumber(G2048Program program) { 
		//list to store levels and store the value of the levels
		val int[] list = #[99,99,99,99,99,99,99,99,99,99,99]
		val String[] listValue = #["","","","","","","","","","",""]
		var warningVar = false
		var warningDup = false
		//collect levels and level elements
		program.statements.forEach[ Statement statement |
			var number = statement.collectLevels()
			var numberValue = statement.collectLevelValue()
			
			if ((!(number===0))){
				list.set(number-1,number)
				listValue.set(number-1, numberValue)
			 }	 
			 			 
		]
		//as there is a chance the level is not up to 11, we need to remove the 99 from the list. we order the list in descending order, then collect how many 99s are there, and 
		//grab the index of the value of how many 99s there are, the index will be the largest level set
		var biggestValue = Collections.max(list)	 	
		if (biggestValue === 99) {
			Collections.sort(list)
			Collections.reverse(list)
			var frequency = Collections.frequency(list,99)
			if(frequency === 10){
				//if there are 10 99s for example: [1,99,99,99,99,99,99,99,99,99,99], that means there is only one level and we can trigger error
				warning('There must not only be one Level', program, G2048Package.Literals.G2048_PROGRAM__STATEMENTS,INVALID_CHECK_LEVEL );
			}
			biggestValue = list.get(frequency)
		}
		Collections.sort(list)

	 	//comparing them in ascending order, any error means there is skip in levels which triggers the error
		for (var i = 1 ; i < (biggestValue+1) ; i++) {
		  if((!(i === (list.get(i-1))))){
		  	warningVar = true
		  }
		  //checking the frequency of each element, if element appears more than once that means there are two levels with same element
		  if((listValue.get(i-1)) != ""){
		  	var wordFrequency = Collections.frequency(listValue,listValue.get(i-1))
		  	if(wordFrequency > 1){
		  		warningDup = true
		  	}
		  }
		}
		if(warningVar){
			warning('Levels must be in consistent order', program, G2048Package.Literals.G2048_PROGRAM__STATEMENTS,INVALID_CHECK_ORDER );	
		}
		if(warningDup){
			warning('Level variables should not be the same', program, G2048Package.Literals.G2048_PROGRAM__STATEMENTS,INVALID_CHECK_DUP );	
		}		
		 
	}
	
	//return 0 if its not Levels related, otherwise return the int of the level it is respective to 
	private dispatch def collectLevels(Statement stmt){  return 0}
	private dispatch def collectLevels(TitleDefineStatement stmt){  return 0}
	private dispatch def collectLevels(LevelDefineStatement stmt){ 
		if(stmt.level === Level.ONE){
			return 1
		} 
		if(stmt.level === Level.TWO){
			return 2
		} 
		if(stmt.level === Level.THREE){
			return 3
		} 	
		if(stmt.level === Level.FOUR){
			return 4
		} 	
		if(stmt.level === Level.FIVE){
			return 5
		}
		if(stmt.level === Level.SIX){
			return 6
		}
		if(stmt.level === Level.SEVEN){
			return 7
		}
		if(stmt.level === Level.EIGHT){
			return 8
		}
		if(stmt.level === Level.NINE){
			return 9
		}
		if(stmt.level === Level.TEN){
			return 10
		}
		if(stmt.level === Level.ELEVEN){
			return 11
		} 	 	 	 	 			
	}	
	
	private dispatch def collectLevelValue(Statement stmt){  return ""}
	private dispatch def collectLevelValue(TitleDefineStatement stmt){  return ""}
	private dispatch def collectLevelValue(LevelDefineStatement stmt){ return stmt.element}		
	
	
}